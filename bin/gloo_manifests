#!/usr/local/bin/python3
# Generate gloo manifests files from Ambassador Mapppings

import json
import os
import re
import subprocess
import sys

import yaml

CORS_POLICY_STRING = """
{
    "allowCredentials": true,
    "allowHeaders": [
        "authorization",
        "content-type",
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "allowMethods": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "OPTIONS"
    ],
    "allowOriginRegex": [
        ".*"
    ],
    "exposeHeaders": [
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "maxAge": "600s"
}
"""
CORS_POLICY=json.loads(CORS_POLICY_STRING)

class VirtualServiceBuilder:
    """Builds a Gloo virtual service manifest"""

    def __init__(self, routes, base, isInternal, cors, useSSL):
        if len(routes) > 0:
            virtual_service = dict()
            virtual_service["apiVersion"] = "gateway.solo.io/v1"
            virtual_service["kind"] = "VirtualService"
            virtual_service["metadata"] = VirtualServiceBuilder.metadata(base, isInternal)
            virtual_service["spec"] = VirtualServiceBuilder.spec(routes, base, isInternal, cors, useSSL)
            self.virtual_service = virtual_service
        else:
            self.virtual_service = None

    def get(self):
        return self.virtual_service

    @staticmethod
    def tls_secret_ref():
        """Return the Kubernetes name and namespace for the secret containing the TLS cert and key
        for the domain being served."""
        secret = dict()
        secret["name"] = "{{.Values.gateway.tlssecret.name}}"
        secret["namespace"] = "{{.Values.gateway.tlssecret.namespace}}"
        return secret
    
    @staticmethod
    def metadata(base, isInternal):
        """Return metadata for virtual service"""
        metadata = dict()
        metadata["name"] = VirtualServiceBuilder.internal_name(base) if isInternal else VirtualServiceBuilder.external_name(base)
        metadata["namespace"] = "{{- .Release.Namespace -}}"
        return metadata
    
    @staticmethod
    def virtual_host_domains(hostname):
        """Return domains"""
        domains = list()
        domains.append(hostname)
        return domains
    
    @staticmethod
    def virtual_host(base, routes, hostname, cors):
        """Return a virtual host"""
        vh = dict()
        vh["domains"] = VirtualServiceBuilder.virtual_host_domains(hostname)
        vh["routes"] = routes
        if cors is not None:
            vh["corsPolicy"] = cors
        return vh
    
    @staticmethod
    def ssl_domains(hostname):
        """Return ssl domains"""
        domains = list()
        domains.append(hostname)
        return domains
    
    @staticmethod
    def ssl_config(hostname):
        """Return the ssl config for the hostname"""
        config = dict()
        config["sniDomains"] = VirtualServiceBuilder.ssl_domains(hostname)
        config["secretRef"] = VirtualServiceBuilder.tls_secret_ref()
        return config
    
    @staticmethod
    def spec(routes, base, isInternal, cors, useSSL):
        spec = dict()
        hostname = VirtualServiceBuilder.internal_hostname(base) if isInternal else VirtualServiceBuilder.external_hostname(base)
        if useSSL:
            spec["sslConfig"] = VirtualServiceBuilder.ssl_config(hostname)
        spec["virtualHost"] = VirtualServiceBuilder.virtual_host(base, routes, hostname, cors)
        spec["displayName"] = hostname
        return spec

    @staticmethod
    def prefix(base):
        return  "{{- .Release.Namespace -}}" + "-" + base

    @staticmethod
    def internal_hostname(base): 
        """ Return the internal DNS name of a virtual service that service routes for base from internal clients."""
        #return VirtualServiceBuilder.prefix(base) + "-internal"
        return '{{include "charts.host.internal.' + base + '" .}}'
    
    @staticmethod
    def external_hostname(base): #{{- define "charts.host.external.api" -}} 
        """ Return the external DNS name of a virtual service that service routes for base from external clients."""
        #return  VirtualServiceBuilder.prefix(base) + ".{{.Values.gateway.domain.name}}"
        return '{{include "charts.host.external.' + base + '" .}}'

    @staticmethod
    def external_name(base):
        """ Return the name of a virtual service that service routes for base from external clients."""
        return  VirtualServiceBuilder.prefix(base) + "-external"

    @staticmethod
    def internal_name(base): #{{- define "charts.host.internal.api" -}}
        """ Return the name of a virtual service that service routes for base from internal clients."""
        #return VirtualServiceBuilder.prefix(base) ++ "-internal"
        return '{{include "charts.host.internal.' + base + '" .}}'

class UpstreamBuilder:
    """Builds a Gloo Upstream manifest"""
    def __init__(self, ref):
        d = dict()
        d["apiVersion"] = "gloo.solo.io/v1"
        d["kind"] = "Upstream"
        d["metadata"] = RoutesBuilder.ref( ref["service"], ref["port"])
        d["spec"] = UpstreamBuilder.spec(ref)
        self.d = d

    def get(self):
        return self.d

    @staticmethod
    def kube_spec(ref):
        kube = dict()
        kube["serviceName"] = ref["service"]
        kube["serviceNamespace"] = namespace()
        kube["servicePort"] = ref["port"]
        return kube

    @staticmethod
    def spec(ref):
        s = dict()
        s["upstreamSpec"] = dict()
        s["upstreamSpec"]["kube"] = UpstreamBuilder.kube_spec(ref)
        return s

class ExternalNameServiceBuilder:
    """Build an ExternalName Service manifest for a given component."""
    def __init__(base):
        self.service = dict()
        self.service["apiVersion"] = "v1"
        self.service["kind"] = "Service"
        self.service["metadata"] = ExternalNameServiceBuilder.metadata(base)
        self.service["spec"] = ExternalNameServiceBuilder.spec()

    def get(self):
        return self.service        

    @staticmethod
    def metadata(base):
        metadata = dict()
        metadata["name"] = VirtualServiceBuilder.internal_name(base) 
        metadata["namespace"] = namespace()
        return metadata
        
    @staticmethod
    def spec():
        spec = dict()
        spec["type"] = "ExternalName"
        spec["externalName"] = GatewayProxyServiceBuilder.name() + "." + GatewayProxyServiceBuilder.namespace() + ".svc.cluster.local"
        spec["ports"] = ExternalNameServiceBuilder.ports()
        return spec
    
    @staticmethod
    def ports():
        ports = list()
        ports.append(ExternalNameServiceBuilder.port())
        return ports

    @staticmethod
    def port():
        port = dict()
        port["port"] = 80
        return port       

class GatewayBuilder:
    """Builds a Gloo Gateway manifest."""

    def __init__(self, useSSL):
        g = dict()
        g["apiVersion"] = "gateway.solo.io/v1"
        g["kind"] = "Gateway"
        g["metadata"] = GatewayBuilder.metadata(useSSL)
        g["bindAddress"] = '::'
        if useSSL:
            g["bindPort"] = 8443
            g["useProxyProto"] = False # XXX check this
        else:
            g["bindPort"] = 8080
            g["useProxyProto"] = False # XXX check this
        g["ssl"] = useSSL
        self.g = g

    def get(self):
        return self.g

    @staticmethod
    def metadata(useSSL):
        metadata = dict()
        suffix = "-ssl" if useSSL else ""
        metadata["name"] = "gateway" + suffix
        metadata["namespace"] = GatewayProxyServiceBuilder.namespace()
        return metadata
    
    @staticmethod
    def GatewayBuilder(useSSL):
        GatewayBuilder = dict()
        GatewayBuilder["apiVersion"] = "gateway.solo.io/v1"
        GatewayBuilder["kind"] = "Gateway"
        GatewayBuilder["metadata"] = GatewayBuilder.metadata(useSSL)
        GatewayBuilder["bindAddress"] = '::'
        if useSSL:
            GatewayBuilder["bindPort"] = 8443
            GatewayBuilder["useProxyProto"] = False # XXX check this
        else:
            GatewayBuilder["bindPort"] = 8080
            GatewayBuilder["useProxyProto"] = False # XXX check this
        GatewayBuilder["ssl"] = useSSL
        return GatewayBuilder

class GatewayProxyServiceBuilder:
    """Builds a Gloo Gateway Proxy Service manifest."""

    def __init__(service_type, useSSL):
        service = dict()
        service["apiVersion"] = "v1"
        service["kind"] = "Service"
        service["metadata"] = GatewayProxyServiceBuilder.metadata(useSSL)
        service["spec"] = GatewayProxyServiceBuilder.spec(service_type, useSSL)
        self.service = service

    def get(self):
        return self.service

    @staticmethod
    def namespace():
        return "{{.Values.gateway.proxy.namespace}}"

    @staticmethod
    def name():
        return  "{{.Values.gateway.proxy.name}}"
    
    @staticmethod
    def labels():
        labels = dict()
        labels["app"] = "gloo"
        labels["gloo"] = "{{.Values.gateway.proxy.name}}"
        return labels
    
    @staticmethod
    def metadata(useSSL):
        metadata = dict()
        metadata["labels"] = GatewayProxyServiceBuilder.labels()
        suffix = "-ssl" if useSSL else ""
        metadata["name"] = "{{.Values.gateway.proxy.name}}" + suffix
        metadata["namespace"] = "{{.Values.gateway.proxy.namespace}}"
        return metadata
    
    @staticmethod
    def ports(useSSL):
        ports = list()
        port = dict()
        if useSSL:
            port["name"] = "https"
            port["port"] = 443
            port["protocol"] = "TCP"
            port["targetPort"] = 8443
        else:
            port["name"] = "http"
            port["port"] = 80
            port["protocol"] = "TCP"
            port["targetPort"] = 8080
        ports.append(port)
        return ports
    
    @staticmethod
    def selector():
        selector = dict()
        selector["gloo"] = "{{.Values.gateway.proxy.name}}"
        return selector
    
    @staticmethod
    def spec(service_type, useSSL):
        spec = dict()
        spec["ports"] = GatewayProxyServiceBuilder.ports(useSSL)
        spec["selector"] = GatewayProxyServiceBuilder.selector()
        if service_type == "elb":
            spec["externalTrafficPolicy"] = "Local"
            spec["type"] = "LoadBalancer"
        elif service_type == "nlb":
            spec["externalTrafficPolicy"] = "Local"
            spec["type"] = "LoadBalancer"
            annotations = dict()
            annotations["service.beta.kubernetes.io/aws-load-balancer-type"] = "nlb"
            spec["annotations"] = annotations
        elif service_type == "cluster":
            spec["type"] = "ClusterIP"
        else:
            return None
        return spec

class RoutesBuilder:
    """Return a dict from host to routes for that host."""

    def __init__(self, mappings):
        self.routes_dict = dict()
        for mapping in mappings:
            self.add(mapping)

        for base,routes in self.routes_dict.items():
            self.routes_dict[base] = RoutesBuilder.ordered(routes)

    def get(self):
        return self.routes_dict

    def add(self, doc):
        """Appends a gloo route to a dictionary of routes whose keys are the virtual hosts."""
        host = doc["host"]
        if host not in self.routes_dict:
            self.routes_dict[host] = list()
        self.routes_dict[host].append(RoutesBuilder.route(doc))

    @staticmethod
    def route(mapping):
        """Return a Gloo route"""
        route = dict()
        route["matcher"] = RoutesBuilder.matcher(mapping)
        plugins = RoutesBuilder.route_plugins(mapping)
        if plugins is not None:
            route["routePlugins"] = plugins
        route["routeAction"] = RoutesBuilder.route_action(mapping)
        return route  
    
    @staticmethod
    def matcher(mapping):
        """Return a gloo matcher"""
        matcher = dict()
        if "prefix_regex" in mapping and mapping[ "prefix_regex"]:
            matcher["regex"] = mapping["prefix"]
        elif "prefix" in mapping and mapping["prefix"]:
            matcher["prefix"] = mapping["prefix"]
        matcher["methods"] = RoutesBuilder.methods(mapping)
        return matcher
    
    @staticmethod
    def route_plugins(mapping):
        """Return a gloo routePlugins"""
        routePlugins = dict()
        if "rewrite" not in mapping:
            routePlugins["prefixRewrite"] = RoutesBuilder.prefix_rewrite("/")
        elif mapping["rewrite"] != "":
            routePlugins["prefixRewrite"] = RoutesBuilder.prefix_rewrite(mapping["rewrite"])
        else:  
            return None
        return routePlugins
    
    @staticmethod
    def methods(mapping):
        methods = list()
        if "method_regex" in mapping and mapping[ "method_regex"]:
            methods = mapping["method"].split("|")
        else:
            methods.append(mapping["method"])
        return methods
    
    @staticmethod
    def prefix_rewrite(path):
        """Return a gloo prefix rewrite rule"""
        prefix_rewrite = dict()
        prefix_rewrite["prefixRewrite"] = path
        return prefix_rewrite
    
    @staticmethod
    def service_and_port(mapping):
        """Return a service and port"""
        s = mapping["service"]
        name = mapping["name"]
        if ":" in s:
            (svc_with_namespace,port) = s.split(":")
        else:
            svc_with_namespace = s
        svc = svc_with_namespace.replace(".default","")
        return svc, int(port)
    
    @staticmethod
    def refs(mappings):
        ref_dict = dict()
        for mapping in mappings:
            service, port = RoutesBuilder.service_and_port(mapping)
            name = service + "-" + str(port) 
            if name not in ref_dict:
                ref_dict[name] = { "service" : service, "port" : port }
        return ref_dict.values()     
    
    @staticmethod
    def ref(service, port):
        """Return a gloo UpstreamBuilder."""
        u = dict()
        u["name"] = namespace() + "-" + service + "-" + str(port)
        u["namespace"] = namespace()
        return u
    
    @staticmethod
    def single(mapping):
        """Return a gloo single."""
        single = dict()
        service, port = RoutesBuilder.service_and_port(mapping)
        single["upstream"] = RoutesBuilder.ref(service, port)
        return single
    
    @staticmethod
    def route_action(mapping):
        """Return a gloo routeAction"""
        routeAction = dict()
        routeAction["single"] = RoutesBuilder.single(mapping)
        return routeAction
    
    @staticmethod
    def ordered(routes):
        """Return a sorted list of http routes from least general to most general."""
        # sort by length of prefix/regex from longest to shortest
        return sorted(routes, key=RoutesBuilder.sort_key, reverse=True)
    
    @staticmethod
    def sort_key(route):
        """ Return a key to use in sorting paths"""
        matcher = route["matcher"]
        if "regex" in matcher:
            return len(matcher["regex"])
        elif "prefix" in matcher:
            return len(matcher["prefix"])
        elif "exact" in matcher:
            return len(matcher["exact"])
        else:
            return 0

class ManifestBuilder:
    """Build all Gloo manifests needed to route to the Tidepool backend for the given protocol."""

    regex = re.compile(r"\{\{[\s-]*\.Release\.Namespace[\s-]*\}\}[\s-]*")

    def __init__(self, protocol, mappings):
        self.manifest_dict = dict()

        all_routes = RoutesBuilder(mappings).get()
        cors_policy = CORS_POLICY if len(all_routes.keys()) > 1 else None
        for base,ordered in all_routes.items():
            self.add(VirtualServiceBuilder(ordered, base, True, None, False).get())
            self.add(VirtualServiceBuilder(ordered, base, False, cors_policy, protocol == "https").get())
            #builder.add(ExternalNameServiceBuilder(base).get())
        for ref in RoutesBuilder.refs(mappings):
            self.add(UpstreamBuilder(ref).get())
        #self.add(GatewayBuilder(False).get())
        #self.add(GatewayBuilder(True).get())
    
    def add(self, manifest):
        if manifest is not None:
            service_name = ManifestBuilder.regex.sub("", manifest["metadata"]["name"])
            service_kind = manifest["kind"].lower()
            name = "gloo-" + service_name + "-" + service_kind
            self.manifest_dict[name] = manifest

    def write(self):
        print(yaml.dump(self.manifest_dict, explicit_start = True, default_flow_style=False))

# ------------- helpers

def namespace():
    return "{{- .Release.Namespace -}}"

# ------------

def main():
    ManifestBuilder(sys.argv[1], yaml.safe_load(sys.stdin)).write()

if __name__ == "__main__":
    main()

#!/usr/local/bin/python3
# Generate gloo manifests files from Ambassador Mapppings

import json
import os
import subprocess
import sys
import yaml

CORS_POLICY_STRING = """
{
    "allowCredentials": true,
    "allowHeaders": [
        "authorization",
        "content-type",
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "allowMethods": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "OPTIONS"
    ],
    "allowOriginRegex": [
        "*"
    ],
    "exposeHeaders": [
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "maxAge": "300s"
}
"""
CORS_POLICY=json.loads(CORS_POLICY_STRING)

def virtual_service_basename(host):
    """Return the Gloo virtual service name."""
    return host.replace("default-", "").replace(".tidepool.org", "") 

def tidepool_tls_secret():
    """Return the Kubernetes name and namespace for the secret containing the TLS cert and key
    for the domain (tidepool-org.org) being served."""
    secret = dict()
    secret["name"] = "tidepool-org"
    secret["namespace"] = "default"
    return secret

def metadata(hostname):
    """Return metadata for virtual service"""
    metadata = dict()
    metadata["name"] = hostname
    metadata["namespace"] = "{{- .Release.Namespace -}}"
    return metadata

def domains(hostname):
    """Return domains"""
    domains = list()
    domains.append(hostname)
    return domains

def sort_key(route):
    """ Return a key to use in sorting paths"""
    matcher = route["matcher"]
    if "regex" in matcher:
        return len(matcher["regex"])
    elif "prefix" in matcher:
        return len(matcher["prefix"])
    elif "exact" in matcher:
        return len(matcher["exact"])
    else:
        return 0

def ordered_routes(routes):
    """Return a sorted list of http routes from least general to most general."""
    # sort by length of prefix/regex from longest to
    return sorted(routes, key=sort_key, reverse=True)

def virtual_host(routes, hostname, cors):
    """Return a virtual host"""
    vh = dict()
    vh["domains"] = domains(hostname)
    vh["name"] = hostname 
    vh["routes"] = routes
    if cors is not None:
        vh["corsPolicy"] = cors
    return vh

def virtual_service_ssl_domains(hostname):
    """Return ssl domains"""
    domains = list()
    domains.append(hostname)
    return domains

def virtual_service_ssl_config(hostname):
    """Return the ssl config for the hostname"""
    config = dict()
    config["sniDomains"] = virtual_service_ssl_domains(hostname)
    config["secretRef"] = tidepool_tls_secret()
    return config

def virtual_service_spec(routes, hostname, cors, useSSL):
    spec = dict()
    if useSSL:
        spec["sslConfig"] = virtual_service_ssl_config(hostname)
    spec["virtualHost"] = virtual_host(routes, hostname, cors)
    return spec

def virtual_service(routes, hostname, cors, useSSL):
    """Return a Gloo virtual service"""
    if len(routes) > 0:
        virtual_service = dict()
        virtual_service["apiVersion"] = "gateway.solo.io/v1"
        virtual_service["kind"] = "VirtualService"
        virtual_service["metadata"] = metadata(hostname)
        virtual_service["spec"] = virtual_service_spec(routes, hostname, cors, useSSL)
        return virtual_service
    else:
        return None

def methods(doc):
    methods = list()
    if "method_regex" in doc and doc[ "method_regex"]:
        methods = doc["method"].split("|")
    else:
        methods.append(doc["method"])
    return methods

def matcher(doc):
    """Return a gloo matcher"""
    matcher = dict()
    if "prefix_regex" in doc and doc[ "prefix_regex"]:
        matcher["regex"] = doc["prefix"]
    elif "prefix" in doc and doc["prefix"]:
        matcher["prefix"] = doc["prefix"]
    matcher["methods"] = methods(doc)
    return matcher

def prefix_rewrite(path):
    """Return a gloo prefix rewrite rule"""
    prefix_rewrite = dict()
    prefix_rewrite["prefixRewrite"] = path
    return prefix_rewrite

def route_plugins(doc):
    """Return a gloo routePlugins"""
    routePlugins = dict()
    if "rewrite" not in doc:
        routePlugins["prefixRewrite"] = prefix_rewrite("/")
    elif doc["rewrite"] != "":
        routePlugins["prefixRewrite"] = prefix_rewrite(doc["rewrite"])
    else:  
        return None
    return routePlugins

def upstream(doc):
    """Return a gloo upstream."""
    upstream = dict()
    s = doc["service"]
    name = doc["name"]
    if ":" in s:
        (svc_with_namespace,port) = s.split(":")
    else:
        svc_with_namespace = s
    svc = svc_with_namespace.replace(".default","")
    
    upstream["name"] = "{{- .Release.Namespace -}}" + "-" + svc + "-" + port
    upstream["namespace"] = "{{- .Release.Namespace -}}"
    return upstream

def single(doc):
    """Return a gloo single."""
    single = dict()
    single["upstream"] = upstream(doc)
    return single

def route_action(doc):
    """Return a gloo routeAction"""
    routeAction = dict()
    routeAction["single"] = single(doc)
    return routeAction

def route(doc):
    """Return a gloo route"""
    route = dict()
    route["matcher"] = matcher(doc)
    plugins = route_plugins(doc)
    if plugins is not None:
        route["routePlugins"] = plugins
    route["routeAction"] = route_action(doc)
    return route

class RoutesDict:
    def __init__(self):
        self.routes_dict = dict()

    def add(self, doc):
        """Appends a gloo route to a dictionary of routes whose keys are the virtual hosts."""
        host = doc["host"]
        if host not in self.routes_dict:
            self.routes_dict[host] = list()
        self.routes_dict[host].append(route(doc))

    def get(self):
          return self.routes_dict

def routes_dict(mappings):
    """Return a dict from host to routes for that host."""
    routes_dict = RoutesDict()
    for mapping in mappings:
        routes_dict.add(mapping)
    return routes_dict.get()

def gateway_proxy_service_labels():
    labels = dict()
    labels["app"] = "gloo"
    labels["gloo"] = "gateway-proxy"
    return labels

def gateway_proxy_service_metadata(useSSL):
    metadata = dict()
    metadata["labels"] = gateway_proxy_service_labels()
    suffix = "-ssl" if useSSL else ""
    metadata["name"] = "gateway-proxy" + suffix
    metadata["namespace"] = "gloo-system"
    return metadata

def gateway_proxy_service_ports(useSSL):
    ports = list()
    port = dict()
    if useSSL:
        port["name"] = "https"
        port["port"] = 443
        port["protocol"] = "TCP"
        port["targetPort"] = 8443
    else:
        port["name"] = "http"
        port["port"] = 80
        port["protocol"] = "TCP"
        port["targetPort"] = 8080
    ports.append(port)
    return ports

def gateway_proxy_service_selector():
    selector = dict()
    selector["gloo"] = "gateway-proxy"
    return selector

def gateway_proxy_service_spec(service_type, useSSL):
    spec = dict()
    spec["ports"] = gateway_proxy_service_ports(useSSL)
    spec["selector"] = gateway_proxy_service_selector()
    if service_type == "elb":
        spec["externalTrafficPolicy"] = "Cluster"
        spec["type"] = "LoadBalancer"
    elif service_type == "nlb":
        spec["externalTrafficPolicy"] = "Cluster"
        spec["type"] = "LoadBalancer"
        annotations = dict()
        annotations["service.beta.kubernetes.io/aws-load-balancer-type"] = "nlb"
        spec["annotations"] = annotations
    elif service_type == "cluster":
        spec["type"] = "ClusterIP"
    else:
        print("bad service type")
        exit()
    return spec

def internal_metadata(base):
    metadata = dict()
    metadata["name"] = "{{.Release.Namespace.}}-" + base + ".gateway-proxy.svc.cluster.local"
    metadata["namespace"] = "{{.Release.Namespace}}"
    return metadata

def internal_port():
    port = dict()
    port["port"] = 80
    return port

def internal_ports():
    ports = list()
    ports.append(internal_port())
    return ports

def internal_spec():
    spec = dict()
    spec["type"] = "ExternalName"
    spec["externalName"] = "gateway-proxy.gloo-system.svc.cluster.local"
    spec["ports"] = internal_ports()
    return spec

def internal_service(base):
     service = dict()
     service["apiVersion"] = "v1"
     service["kind"] = "Service"
     service["metadata"] = internal_metadata(base)
     service["spec"] = internal_spec()
     return service

def gateway_metadata(useSSL):
    metadata = dict()
    suffix = "-ssl" if useSSL else ""
    metadata["name"] = "gateway" + suffix
    metadata["namespace"] = "gloo-system"
    return metadata

def gateway(useSSL):
    gateway = dict()
    gateway["apiVersion"] = "gateway.solo.io/v1"
    gateway["kind"] = "Gateway"
    gateway["metadata"] = gateway_metadata(useSSL)
    gateway["bindAddress"] = '::'
    if useSSL:
        gateway["bindPort"] = 8443
        gateway["useProxyProto"] = False # XXX check this
    else:
        gateway["bindPort"] = 8080
        gateway["useProxyProto"] = False # XXX check this
    gateway["ssl"] = useSSL
    return gateway

def gateway_proxy_service(service_type, useSSL):
    service = dict()
    service["apiVersion"] = "v1"
    service["kind"] = "Service"
    service["metadata"] = gateway_proxy_service_metadata(useSSL)
    service["spec"] = gateway_proxy_service_spec(service_type, useSSL)
    return service

def external_hostname(base):
    return  "{{.Release.Namespace}}-" + base + ".tidepool.org"

def internal_hostname(base):
    return "{{.Release.Namespace}}-" + base + ".svc.cluster.local"

class ManifestBuilder:
    def __init__(self):
        self.manifest_dict = dict()
    
    def add(self, manifest, name):
        self.manifest_dict[name] = manifest

    def get(self):
        return self.manifest_dict

def manifests_from_mappings(protocol, mappings):
    """Generate Gloo manifests for the given external protocol (http or https)."""
    use_https = protocol == "https"
    builder = ManifestBuilder()
    all_routes = routes_dict(mappings)
    cors_policy = CORS_POLICY if len(all_routes.keys()) > 1 else None
    for host,routes in all_routes.items():
        base = virtual_service_basename(host)
        ordered = ordered_routes(routes)
        external_virtual_service = virtual_service(ordered, external_hostname(base), cors_policy, use_https)
        internal_virtual_service = virtual_service(ordered, internal_hostname(base), None, False)
        builder.add(internal_virtual_service, base + "-internal-virtual-service")
        builder.add(external_virtual_service, base + "-external-virtual-service")
        builder.add(internal_service(base), base + "-gateway-proxy-internal")
    builder.add(gateway(False), "gateway")
    builder.add(gateway(True), "gateway-ssl")
    if use_https:
        builder.add(gateway_proxy_service("elb", True), "gateway-proxy-service-ssl")
        builder.add(gateway_proxy_service("cluster", False), "gateway-proxy-service")
    else:
        builder.add(gateway_proxy_service("elb", False), "gateway-proxy-service")
    return builder.get()

def write_manifests(manifests):
    print(yaml.dump(manifests, explicit_start = True, default_flow_style=False))


"""
Example output:
---
kind: Service
apiVersion: v1
metadata:
  name: api.gateway-proxy.svc.cluster.local
  namespace: qa1
spec:
  type: ExternalName
  externalName: gateway-proxy.gloo-system.svc.cluster.local
  ports:
  - port: 80
---
apiVersion: gateway.solo.io/v1
kind: Gateway
metadata:
  name: gateway-ssl
  namespace: gloo-system
spec:
  bindAddress: '::'
  bindPort: 8443
  ssl: true
  useProxyProto: false
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: gloo
    gloo: gateway-proxy
  name: gateway-proxy
  namespace: gloo-system
spec:
  externalTrafficPolicy: Cluster
  ports:
  - name: http
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    gloo: gateway-proxy
---
apiVersion: gateway.solo.io/v1
kind: VirtualService
metadata:
  name: api-vs-{{.Release.Namespace}}
  namespace: {{.Release.Namespace}}
spec:
  sslConfig:
    sniDomains:
    - {{ include "charts.host.api" . }}
    secretRef:
      name: tidepool-org
      namespace: default
  virtualHost:
    domains:
    - {{ include "charts.host.api" . }}
    name: {{.Release.Namespace}}.api
    routes:
    - matcher:
        prefix: /userservices/
      routeAction:
        single:
          upstream:
            name: {{.Release.Namespace}}-platform-user-{{ .Values.platformUser.port }}
            namespace: gloo-system
    - matcher:
        methods:
        - POST
        - GET
        - DELETE
        regex: /v1/users/[^/]+/images
      routeAction:
        single:
          upstream:
            name: {{.Release.Namespace}}-platform-image-{{ .Values.platformImage.port }}
            namespace: gloo-system
    - matcher:
        prefix: /dataservices/
      routeAction:
        single:
          upstream:
            name: {{.Release.Namespace}}-platform-data-{{ .Values.platformData.port }}
            namespace: gloo-system
      routePlugins:
        prefixRewrite:
          prefixRewrite: /
{{ end }}
"""

def main():
    protocol = "https" if len(sys.argv) == 1 else "http" 
    write_manifests(manifests_from_mappings(protocol, yaml.safe_load(sys.stdin)))

if __name__ == "__main__":
    main()

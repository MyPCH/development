#!/usr/local/bin/python3
# Generate gloo manifests files from Ambassador Mapppings

import json
import os
import re
import subprocess
import sys

import yaml

CORS_POLICY_STRING = """
{
    "allowCredentials": true,
    "allowHeaders": [
        "authorization",
        "content-type",
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "allowMethods": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "OPTIONS"
    ],
    "allowOriginRegex": [
        "*.{{.Values.gateway.domain.name}}"
    ],
    "exposeHeaders": [
        "x-tidepool-session-token",
        "x-tidepool-trace-request",
        "x-tidepool-trace-session"
    ],
    "maxAge": "600s"
}
"""
CORS_POLICY=json.loads(CORS_POLICY_STRING)

def tls_secret():
    """Return the Kubernetes name and namespace for the secret containing the TLS cert and key
    for the domain being served."""
    secret = dict()
    secret["name"] = "{{.Values.gateway.tlssecret.name}}"
    secret["namespace"] = "{{.Values.gateway.tlssecret.namespace}}"
    return secret

def virtual_service_metadata(base, isInternal):
    """Return metadata for virtual service"""
    metadata = dict()
    metadata["name"] = internal_name(base) if isInternal else external_name(base)
    metadata["namespace"] = "{{- .Release.Namespace -}}"
    return metadata

def domains(hostname):
    """Return domains"""
    domains = list()
    domains.append(hostname)
    return domains

def sort_key(route):
    """ Return a key to use in sorting paths"""
    matcher = route["matcher"]
    if "regex" in matcher:
        return len(matcher["regex"])
    elif "prefix" in matcher:
        return len(matcher["prefix"])
    elif "exact" in matcher:
        return len(matcher["exact"])
    else:
        return 0

def ordered_routes(routes):
    """Return a sorted list of http routes from least general to most general."""
    # sort by length of prefix/regex from longest to
    return sorted(routes, key=sort_key, reverse=True)


def virtual_host(routes, hostname, cors):
    """Return a virtual host"""
    vh = dict()
    vh["domains"] = domains(hostname)
    vh["name"] = hostname 
    vh["routes"] = routes
    if cors is not None:
        vh["corsPolicy"] = cors
    return vh

def virtual_service_ssl_domains(hostname):
    """Return ssl domains"""
    domains = list()
    domains.append(hostname)
    return domains

def virtual_service_ssl_config(hostname):
    """Return the ssl config for the hostname"""
    config = dict()
    config["sniDomains"] = virtual_service_ssl_domains(hostname)
    config["secretRef"] = tls_secret()
    return config


def virtual_service_spec(routes, base, isInternal, cors, useSSL):
    spec = dict()
    hostname = internal_hostname(base) if isInternal else external_hostname(base)
    if useSSL:
        spec["sslConfig"] = virtual_service_ssl_config(hostname)
    spec["virtualHost"] = virtual_host(routes, hostname, cors)
    spec["displayName"] = hostname
    return spec

def virtual_service(routes, base, isInternal, cors, useSSL):
    """Return a Gloo virtual service"""
    if len(routes) > 0:
        virtual_service = dict()
        virtual_service["apiVersion"] = "gateway.solo.io/v1"
        virtual_service["kind"] = "VirtualService"
        virtual_service["metadata"] = virtual_service_metadata(base, isInternal)
        virtual_service["spec"] = virtual_service_spec(routes, base, isInternal, cors, useSSL)
        return virtual_service
    else:
        return None

def methods(mapping):
    methods = list()
    if "method_regex" in mapping and mapping[ "method_regex"]:
        methods = mapping["method"].split("|")
    else:
        methods.append(mapping["method"])
    return methods

def matcher(mapping):
    """Return a gloo matcher"""
    matcher = dict()
    if "prefix_regex" in mapping and mapping[ "prefix_regex"]:
        matcher["regex"] = mapping["prefix"]
    elif "prefix" in mapping and mapping["prefix"]:
        matcher["prefix"] = mapping["prefix"]
    matcher["methods"] = methods(mapping)
    return matcher

def prefix_rewrite(path):
    """Return a gloo prefix rewrite rule"""
    prefix_rewrite = dict()
    prefix_rewrite["prefixRewrite"] = path
    return prefix_rewrite

def route_plugins(mapping):
    """Return a gloo routePlugins"""
    routePlugins = dict()
    if "rewrite" not in mapping:
        routePlugins["prefixRewrite"] = prefix_rewrite("/")
    elif mapping["rewrite"] != "":
        routePlugins["prefixRewrite"] = prefix_rewrite(mapping["rewrite"])
    else:  
        return None
    return routePlugins

def service_and_port(mapping):
    """Return a service and port"""
    s = mapping["service"]
    name = mapping["name"]
    if ":" in s:
        (svc_with_namespace,port) = s.split(":")
    else:
        svc_with_namespace = s
    svc = svc_with_namespace.replace(".default","")
    return svc, int(port)

def upstream_refs(mappings):
    ref_dict = dict()
    for mapping in mappings:
        service, port = service_and_port(mapping)
        name = service + "-" + str(port) 
        if name not in ref_dict:
            ref_dict[name] = { "service" : service, "port" : port }
    return ref_dict.values()     

def upstream_ref(service, port):
    """Return a gloo upstream."""
    upstream = dict()
    upstream["name"] = "{{- .Release.Namespace -}}" + "-" + service + "-" + str(port)
    upstream["namespace"] = "{{- .Release.Namespace -}}"
    return upstream

def single(mapping):
    """Return a gloo single."""
    single = dict()
    service, port = service_and_port(mapping)
    single["upstream"] = upstream_ref(service, port)
    return single

def route_action(mapping):
    """Return a gloo routeAction"""
    routeAction = dict()
    routeAction["single"] = single(mapping)
    return routeAction

def route(mapping):
    """Return a gloo route"""
    route = dict()
    route["matcher"] = matcher(mapping)
    plugins = route_plugins(mapping)
    if plugins is not None:
        route["routePlugins"] = plugins
    route["routeAction"] = route_action(mapping)
    return route

class RoutesDict:
    def __init__(self):
        self.routes_dict = dict()

    def add(self, doc):
        """Appends a gloo route to a dictionary of routes whose keys are the virtual hosts."""
        host = doc["host"]
        if host not in self.routes_dict:
            self.routes_dict[host] = list()
        self.routes_dict[host].append(route(doc))

    def get(self):
          return self.routes_dict

def routes_dict(mappings):
    """Return a dict from host to routes for that host."""
    routes_dict = RoutesDict()
    for mapping in mappings:
        routes_dict.add(mapping)
    return routes_dict.get()

def kube_spec(ref):
    kube = dict()
    kube["serviceName"] = ref["service"]
    kube["serviceNamespace"] = "{{.Release.Namespace}}"
    kube["servicePort"] = ref["port"]
    kube["selector"] = dict()
    return kube

def upstream_spec(ref):
    spec = dict()
    spec["upstreamSpec"] = dict()
    spec["upstreamSpec"]["kube"] = kube_spec(ref)
    return spec 

def upstream_kind(ref):
    upstream = dict()
    upstream["apiVersion"] = "gloo.solo.io/v1"
    upstream["kind"] = "Upstream"
    upstream["metadata"] = upstream_ref( ref["service"], ref["port"])
    upstream["spec"] = upstream_spec(ref)
    return upstream

def gateway_proxy_service_labels():
    labels = dict()
    labels["app"] = "gloo"
    labels["gloo"] = "{{.Values.gateway.proxy.name}}"
    return labels

def gateway_proxy_service_metadata(useSSL):
    metadata = dict()
    metadata["labels"] = gateway_proxy_service_labels()
    suffix = "-ssl" if useSSL else ""
    metadata["name"] = "{{.Values.gateway.proxy.name}}" + suffix
    metadata["namespace"] = "{{.Values.gateway.proxy.namespace}}"
    return metadata

def gateway_proxy_service_ports(useSSL):
    ports = list()
    port = dict()
    if useSSL:
        port["name"] = "https"
        port["port"] = 443
        port["protocol"] = "TCP"
        port["targetPort"] = 8443
    else:
        port["name"] = "http"
        port["port"] = 80
        port["protocol"] = "TCP"
        port["targetPort"] = 8080
    ports.append(port)
    return ports

def gateway_proxy_service_selector():
    selector = dict()
    selector["gloo"] = "{{.Values.gateway.proxy.name}}"
    return selector

def gateway_proxy_service_spec(service_type, useSSL):
    spec = dict()
    spec["ports"] = gateway_proxy_service_ports(useSSL)
    spec["selector"] = gateway_proxy_service_selector()
    if service_type == "elb":
        spec["externalTrafficPolicy"] = "Local"
        spec["type"] = "LoadBalancer"
    elif service_type == "nlb":
        spec["externalTrafficPolicy"] = "Local"
        spec["type"] = "LoadBalancer"
        annotations = dict()
        annotations["service.beta.kubernetes.io/aws-load-balancer-type"] = "nlb"
        spec["annotations"] = annotations
    elif service_type == "cluster":
        spec["type"] = "ClusterIP"
    else:
        print("bad service type")
        exit()
    return spec

def internal_metadata(base):
    metadata = dict()
    metadata["name"] = internal_name(base) 
    metadata["namespace"] = "{{.Release.Namespace}}"
    return metadata

def internal_port():
    port = dict()
    port["port"] = 80
    return port

def internal_ports():
    ports = list()
    ports.append(internal_port())
    return ports

def internal_spec():
    spec = dict()
    spec["type"] = "ExternalName"
    spec["externalName"] = "{{.Values.gateway.proxy.name}}.{{.Values.gateway.proxy.namespace}}.svc.cluster.local"
    spec["ports"] = internal_ports()
    return spec

def internal_service(base):
     service = dict()
     service["apiVersion"] = "v1"
     service["kind"] = "Service"
     service["metadata"] = internal_metadata(base)
     service["spec"] = internal_spec()
     return service

def gateway_metadata(useSSL):
    metadata = dict()
    suffix = "-ssl" if useSSL else ""
    metadata["name"] = "gateway" + suffix
    metadata["namespace"] = "{{.Values.gateway.proxy.namespace}}"
    return metadata

def gateway(useSSL):
    gateway = dict()
    gateway["apiVersion"] = "gateway.solo.io/v1"
    gateway["kind"] = "Gateway"
    gateway["metadata"] = gateway_metadata(useSSL)
    gateway["bindAddress"] = '::'
    if useSSL:
        gateway["bindPort"] = 8443
        gateway["useProxyProto"] = False # XXX check this
    else:
        gateway["bindPort"] = 8080
        gateway["useProxyProto"] = False # XXX check this
    gateway["ssl"] = useSSL
    return gateway

def gateway_proxy_service(service_type, useSSL):
    service = dict()
    service["apiVersion"] = "v1"
    service["kind"] = "Service"
    service["metadata"] = gateway_proxy_service_metadata(useSSL)
    service["spec"] = gateway_proxy_service_spec(service_type, useSSL)
    return service

def external_name(base):
    return  "{{.Release.Namespace}}-" + base + "-external"

def internal_name(base):
    return "{{.Release.Namespace}}-" + base + "-internal"

def internal_hostname(base):
    return "{{.Release.Namespace}}-" + base + "-internal"

def external_hostname(base):
    return  "{{.Release.Namespace}}-" + base + ".{{.Values.gateway.domain.name}}"

class ManifestBuilder:
    regex = re.compile(r"\{\{[\s-]*\.Release\.Namespace[\s-]*\}\}[\s-]*")

    def __init__(self):
        self.manifest_dict = dict()
    
    def add(self, manifest):
        if manifest is not None:
            service_name = ManifestBuilder.regex.sub("", manifest["metadata"]["name"])
            service_kind = manifest["kind"].lower()
            name = "gloo-" + service_name + "-" + service_kind
            self.manifest_dict[name] = manifest

    def get(self):
        return self.manifest_dict

def manifests_from_mappings(protocol, mappings):
    """Generate Gloo manifests for the given external protocol (http or https)."""
    use_https = protocol == "https"
    builder = ManifestBuilder()
    all_routes = routes_dict(mappings)
    cors_policy = CORS_POLICY if len(all_routes.keys()) > 1 else None
    for base,routes in all_routes.items():
        ordered = ordered_routes(routes)
        builder.add(virtual_service(ordered, base, True, None, False))
        builder.add(virtual_service(ordered, base, False, cors_policy, use_https))
        #builder.add(internal_service(base))
    for ref in upstream_refs(mappings):
        builder.add(upstream_kind(ref))
    #builder.add(gateway(False))
    #builder.add(gateway(True))
    return builder.get()

def write_manifests(manifests):
    print(yaml.dump(manifests, explicit_start = True, default_flow_style=False))

def main():
    protocol = sys.argv[1]
    write_manifests(manifests_from_mappings(protocol, yaml.safe_load(sys.stdin)))

if __name__ == "__main__":
    main()

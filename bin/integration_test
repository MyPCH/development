#!/bin/bash 
# This script is used to run integration tests of a new image of a service with an existing Kubernetes cluster.
#
# Pre-requisites:
# 1) Set up a wildcard domain in Route53 for all *.integration-test.tidepool.org -> integration test K8s cluster
# 2) In the K8s cluster, install helm and weave flux. This will install the (unconfigured) API gateway.

# This script
# 1) creates a declarative description of the test settings in the `dev-ops` repo;
# 2) spins up a new "environment" inside an existing Kubernetes cluster (the "integration-test" cluster);
# 3) runs the integration test using Ghost Inspector;
# 4) frees the resources used in Kubernetes to run the test;
# 5) captures the test results and commits them to the repo; and,
# 6) returns an exit status code of 1 for test failure and 0 for test success.

# The name of the service to be tested, e.g hydrophone, blip, auth, image.
SERVICE=${1:-hydrophone}

# The tag of the image to be tested, e.g. "develop-657ba6265ad38ce7c61be77b5642e99c0ede6945"
TAG=${2:-develop-657ba6265ad38ce7c61be77b5642e99c0ede6945}

# The name of the cluster as represented in the Git repo.
CLUSTER_GIT_NAME=${3:-integration-test}

# The base environment for the tests.  This determines which versions of the OTHER services are to be used in the test.
BASE_ENVIRONMENT=${4:-develop} # other options are "master", "released"

# The name of the environment that we will create within a K8s namespace of the same name
ENVIRONMENT=${SERVICE}-${TAG:0:20}

# The URL at which the test environment can be reached.
CLUSTER_URL=http://${ENVIRONMENT}.integration-test.tidepool.org

# Create declarative description of the test environment for Weave Flux
mytmpdir=$(mktemp -d "./zombie.XXXXXXXXX")
cd $mytmpdir
mkdir ${ENVIRONMENT}
cd ${ENVIRONMENT}
git clone git@github.com:tidepool-org/dev-ops
cd dev-ops/clusters/${CLUSTER_GIT_NAME}/flux/environments
subdir=$(date +%F)/${ENVIRONMENT}
mkdir -p ${subdir}
cp -r ${BASE_ENVIRONMENT}/* ${subdir}/ 
cd ${subdir}
# Patch the tidepool-helmrelease to add the new test image for the service and to turn off automatic updates of the images
# The OTHER images will be selected based on the configuration on the base environment
YQ="docker run -v ${PWD}:/workdir mikefarah/yq yq"
${YQ} w -i tidepool-helmrelease.yaml metadata.annotations[flux.weave.works/automated]: false
${YQ} w -i tidepool-helmrelease.yaml spec.values.${SERVICE}.image: tidepool/${SERVICE}:${TAG}
${YQ} w -i tidepool-helmrelease.yaml spec.values.domain: integration-test.tidepool.org
${YQ} w -i tidepool-helmrelease.yaml spec.releaseName: tidepool-${ENVIRONMENT}
${YQ} d -i tidepool-helmrelease.yaml metadata.annotations[flux.weave.works/tag.${SERVICE}]
${YQ} w -i mongodb-helmrelease.yaml spec.releaseName tidepool-mongo-${ENVIRONMENT}
# Set the environment/namespace in all of the Kubernetes resource manifests
for file in $(find . -name \*.yaml -print)
do
	${YQ} w -i $file metadata.namespace ${ENVIRONMENT}
done

# Save the results to GitHub.  This repo is polled by Weave Flux, which will create the test environment in the cluster.
git add .
git commit -m "Creating integration test environment ${ENVIRONMENT} to test ${SERVICE}:${TAG}"
git push

# Wait for running state @see https://github.com/zlabjp/kubernetes-scripts/blob/master/wait-until-pods-readya to do this reliably. 
# Unfortunately, this method in zlabjp requires direct access to the cluster.  We need another way! For now we sleep.
sleep 300

# Run integration test(s)
curl "https://api.ghostinspector.com/v1/suites/$GHOST_SUITE_ID/execute/?apiKey=$GHOST_API_KEY&startUrl=${CLUSTER_URL} > ghostinspector.json
success=$(grep -c '"passing":false' ghostinspector.json)

# Clean up test cluster by renaming manifest files. This causes Weave to free the resources, if weave was started with garbage collection on.
for file in $(find . -name \*.yaml -print)
do
	mv $file $file.off
done
git add .
git commit -m "Turn off ${ENVIRONMENT} by rename .yaml files to .yaml.off."
git push

#clean up local file system
cd
rm -rf $mytmpdir

if [ ${success} -ne 0 ]; then exit 1; fi

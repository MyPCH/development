#!/bin/bash
#
# Configure EKS cluster
#
# Usage: $0
#

set -o pipefail

# set up colors to use for output
function define_colors {
	RED=`tput setaf 1`
	GREEN=`tput setaf 2`
	MAGENTA=`tput setaf 5`
	RESET=`tput sgr0`
}

function panic {
	echo "${RED}[✖] ${1}${RESET}"
	exit 1
}

function info {
	echo "${MAGENTA}[√] ${1}${RESET}"
}

function add_file {
	echo "${GREEN}[ℹ] adding ${1}${RESET}"
}

function add_names {
	while read -r line
	do 
		add_file $line
	done
}

function rename_file {
	echo "${GREEN}[√] renaming ${1} ${2}${RESET}"
}

function confirm {
	local msg=$1
	read -p "${RED}$msg${RESET} " -n 1 -r
	if [[ ! $REPLY =~ ^[Yy]$ ]]
	then
		exit 1
	else
		echo
	fi
}

# require that REMOTE_REPO env variable exists, expand REMOTE_REPO into full name
function check_remote_repo {

	if [ -z "$REMOTE_REPO" ]
	then
		panic "must provide REMOTE_REPO"
	fi

	if [[ $REMOTE_REPO != git@github.com* ]]
	then
		REMOTE_REPO="git@github.com:tidepool-org/$REMOTE_REPO"
	fi
}

# create temporary workspace to clone Git repos into, change to that directory
function setup_tmpdir {
	TMP_DIR=`mktemp -d 2>/dev/null || mktemp -d -t 'TMP_DIR'`
	trap "rm -rf $TMP_DIR" EXIT
	cd $TMP_DIR
}

# clone config repo, change to that directory
function clone_remote {
	cd $TMP_DIR
	git clone $REMOTE_REPO
	if [ $? -ne 0 ]
	then
		panic "Cannot clone $REMOTE_REPO"
	fi
	cd $(basename $REMOTE_REPO)
}

# clone quickstart repo, export QUICKSTART_DIR
function set_quickstart_dir {
	info "cloning quickstart"
	pushd $TMP_DIR >/dev/null 2>&1
	git clone git@github.com:/tidepool-org/tidepool-quickstart
	export QUICKSTART_DIR=$(realpath tidepool-quickstart)
	popd >/dev/null 2>&1
}

# clone development repo, exports DEV_DIR and CHART_DIR
function set_development_dir {
	info "cloning development tools"
	pushd $TMP_DIR >/dev/null 2>&1
	git clone git@github.com:/tidepool-org/development
	cd development
       	git checkout k8s
	DEV_DIR=$(realpath .)
	CHART_DIR=${DEV_DIR}/charts/tidepool/0.1.7
	popd >/dev/null 2>&1
}

# clone secret-map repo, export SM_DIR
function clone_secret_map {
	info "cloning secret-map"
	pushd $TMP_DIR >/dev/null 2>&1
	git clone git@github.com:/tidepool-org/secret-map
	SM_DIR=$(realpath ./secret-map)
	popd >/dev/null 2>&1
}

function get_config {
	yq r values.yaml -j
}

function must_get_value {
	local val=$(yq r values.yaml -j $1 | sed -e 's/"//g' -e "s/'//g")
	if [ $? -ne 0 -o "$val" == "null" -o "$val" == "" ]
	then
		panic "Missing $1 from values.yaml file."
	fi
	echo $val
}

function get_cluster {
	must_get_value "cluster.metadata.name"
}

function get_region {
	must_get_value "cluster.metadata.region"
}

function get_email {
	must_get_value "email" 
}

function get_aws_account {
	must_get_value "aws.accountNumber"
}

function get_environments {
	yq r values.yaml environments | sed -e "/^  .*/d" -e s/:.*//
}

function get_iam_users {
	yq r values.yaml aws.iamUsers | sed -e "s/- //" -e 's/"//g'
}

function get_bucket {
	local env = $1
	local bucket=$(yq r values.yaml environments.${env}.asset | sed -e "/^  .*/d" -e s/:.*//)
	if [ "$bucket" == "null" ]
	then
		local cluster=$(get_cluster)
		echo "tidepool-${cluster}-${env}-asset"
	else
		echo $bucket
	fi
}

function make_assets {
	local env
	for env in $(get_environments)
	do
		local bucket=$(get_bucket $env)
  		info "creating asset bucket $bucket"
  		aws s3 mb s3://$bucket
  		info "copying  dev assets into $bucket"
  		aws s3 cp s3://tidepool-dev-asset s3://$bucket
	done
}

# clean up
function cleanup {
	rm -rf $TMP_DIR
}

function get_helm_home {
	echo ${HELM_HOME:-~/.helm}
}

# make TLS certificate to allow local helm client to access tiller with TLS
function make_cert {
	local cluster=$(get_cluster)
	local helm_home=$(get_helm_home)

	info "installing helm client cert for cluster $cluster"

	info "retrieving ca.pem from AWS secrets manager"
	aws secretsmanager get-secret-value --secret-id $cluster/flux/ca.pem | jq '.SecretString' | sed -e 's/"//g' \
-e 's/\\n/\
/g' >ca.pem

	if [ $? -ne 0 ]
	then
		panic "failed to retrieve ca.pem from AWS secrets manager"
	fi

	info "retrieving ca-key.pem from AWS secrets manager"
	aws secretsmanager get-secret-value --secret-id $cluster/flux/ca-key.pem | jq '.SecretString' | sed -e 's/"//g'  \
-e 's/\\n/\
/g' >ca-key.pem

	if [ $? -ne 0 ]
	then
		panic "failed to retrieve ca-key.pem from AWS secrets manager"
	fi
	
	local helm_cluster_home=${helm_home}/clusters/$cluster

	info "creating cert in ${helm_cluster_home}"
	local tiller_hostname=tiller-deploy.flux
	local user_name=helm-client

	echo '{"signing":{"default":{"expiry":"43800h","usages":["signing","key encipherment","server auth","client auth"]}}}' > ca-config.json
	echo '{"CN":"'$user_name'","hosts":[""],"key":{"algo":"rsa","size":4096}}' | cfssl gencert \
  	-config=ca-config.json -ca=ca.pem -ca-key=ca-key.pem \
  	-hostname="$tiller_hostname" - | cfssljson -bare $user_name
	
	rm -rf $helm_cluster_home
	mkdir -p $helm_cluster_home
	cp helm-client.pem $helm_cluster_home/cert.pem
	add_file $helm_cluster_home/cert.pem
	cp helm-client-key.pem $helm_cluster_home/key.pem
	add_file $helm_cluster_home/key.pem
	cp ca.pem $helm_cluster_home/ca.pem
	add_file $helm_cluster_home/ca.pem
	rm -f $helm_home/{cert.pem,key.pem,ca.pem}
	cp $helm_cluster_home/{cert.pem,key.pem,ca.pem} $helm_home
	
	if [ "$TILLER_NAMESPACE" != "flux"  -o "$HELM_TLS_ENABLE" != "true" ]
	then
    		info "you must do this to use helm:"
    		info "export TILLER_NAMESPACE=flux"
    		info "export HELM_TLS_ENABLE=true"
	fi
}

function confirm_github_token {
	if [ -z "$GITHUB_TOKEN" ]
	then
        	panic "\$GITHUB_TOKEN required."
	fi
}

function get_kubeconfig {
	kc=$(yq r values.yaml kubeconfig | sed -e 's/"//g' -e "s/'//g")
	kc=~/.kube/config
	realpath $kc
}


function make_cluster {
	local cluster=$(get_cluster)
	info "creating cluster $cluster"

	eksctl create cluster -f config.yaml --kubeconfig ./kubeconfig.yaml
	git pull

	if [ $? -ne 0 ]
	then
		panic "eksctl create cluster failed."
	fi
	add_file "./kubeconfig.yaml"
}
	
function merge_kubeconfig {
	set -xv
	local localKubeConfig=$(realpath ./kubeconfig.yaml)
	local kubeconfig=$(get_kubeconfig)
	if [ "$kubeconfig" != "$localKubeConfig" ]
	then
    		if [ -f "$kubeconfig" ]
    		then
        		info "merging kubeconfig into $kubeconfig"
        		KUBECONFIG=$kubeconfig:$localKubeConfig kubectl config view --flatten >$TMP_DIR/updated.yaml
        		mv $TMP_DIR/updated.yaml $kubeconfig
    		else
        		mkdir -p $(dirname $kubeconfig)
        		info "creating new $kubeconfig" 
        		cp $localKubeConfig $kubeconfig
    		fi
	fi
}

# confirms that values file exists or panics
function check_values_exists {
	if [ ! -f values.yaml ]
	then
		panic "No values.yaml file."
	fi
}

# remove computed pkgs 
function reset_config_dir {
	mv values.yaml $TMP_DIR/
	if [ $(ls | wc -l) -ne 0 ]
	then
		confirm "Are you sure that you want to remote prior contents (except values.yaml)?"
		info "resetting config repo"
		rm -rf pkgs
	fi
	mv $TMP_DIR/values.yaml .
}

function make_config {
	local cluster=$(get_cluster)
	local config=$(get_config)
	info "creating manifests for cluster $cluster"
	go get github.com/subfuzion/envtpl/...
	local pkgs=""
	local dir
	for dir in $(ls $QUICKSTART_DIR/pkgs)
	do
		local pkg=$(basename $dir)
		local enabled=$(yq r values.yaml pkgs.${pkg}.enabled)
		if [ "$enabled" == "true" ]
		then
			pkgs="${pkgs} pkgs/$pkg"
        	fi
	done
	info "creating namespaces and package manifests"
	local dir
	for dir in namespaces $pkgs
	do
		local fullpath
  		for fullpath in $(find $QUICKSTART_DIR/$dir -type f -print)
  		do
			local filename=$(basename $fullpath)
			mkdir -p $dir
			if [ "${filename: -5}" == ".tmpl" ]
			then
				add_file $dir/${filename%.tmpl}
				envtpl $fullpath >$dir/${filename%.tmpl}
        		elif [ "${filename: -12}" == "-secret.yaml" ]
			then
				echo >/dev/null
        		elif [ "${filename: -5}" == ".yaml" ]
			then
				add_file $dir/$filename
				cp $fullpath $dir/$filename
			elif [ "${filename: -8}" == ".jsonnet" ]
			then
				add_file $dir/${filename%.jsonnet}
				jsonnet --tla-code config="$config" $fullpath | yq r - > $dir/${filename%.jsonnet}
			fi
  		done
	done
	
	info "creating eksctl ClusterConfig manifest"
	add_file "config.yaml"
	jsonnet --tla-code config="$config" ${QUICKSTART_DIR}/eksctl/cluster_config.jsonnet | yq r - > config.yaml
	
	local env
	for env in $(get_environments)
	do
		local envdir=environments/$env
		mkdir -p $envdir
	
		info "creating $env environment manifests"
		add_file environments/$env/tidepool-helmrelease.yaml
		add_file namespaces/${env}-namespace.yaml
		jsonnet --tla-code config="$config" --tla-str namespace=$env  ${QUICKSTART_DIR}/tidepool/tidepool-helmrelease.jsonnet | yq r - > $envdir/tidepool-helmrelease.yaml
		jsonnet --tla-code config="$config" --tla-str namespace=$env  ${QUICKSTART_DIR}/tidepool/tidepool-namespace.jsonnet | yq r - > namespaces/${env}-namespace.yaml
	done
}
	
# persists changes to config repo in GitHub
function save_changes {
	info "saving changes to config repo"
	git add .
	git commit -m "$1"
	git push
}

function confirm_cluster_exists {
	local cluster=$(get_cluster)
	eksctl get cluster --name $cluster
	if [ $? -ne 0 ]
	then
		panic "cluster $cluster does not exist."
	fi
}

# install flux into cluster
function make_flux {
	local cluster=$(get_cluster)
	local email=$(get_email)
	
	info "installing flux into cluster $cluster"

	EKSCTL_EXPERIMENTAL=true unbuffer eksctl install \
		flux -f config.yaml --git-url=${REMOTE_REPO}.git --git-email=$email --git-label=$cluster  | tee  $TMP_DIR/eksctl.out
	
	if [  $? -ne 0 ]
	then
		panic "eksctl install flux failed."
	fi
	
	git pull
}

function save_ca {
	info "saving certificate authority TLS pem and key to AWS secrets manager"
	local cluster=$(get_cluster)
	local dir=$(cat $TMP_DIR/eksctl.out | grep "Public key infrastructure" | sed -e 's/^.*"\(.*\)".*$/\1/')

	aws secretsmanager describe-secret --secret-id $cluster/flux/ca.pem 2>/dev/null
	if [ $? -ne 0 ]
	then
    		aws secretsmanager create-secret --name $cluster/flux/ca.pem --secret-string "$(cat $dir/ca.pem)"
    		if [ $? -ne 0 ]
    		then
	    		panic "failed to create ca.pem to AWS"
    		fi
    		aws secretsmanager create-secret --name $cluster/flux/ca-key.pem --secret-string "$(cat $dir/ca-key.pem)"
    		if [ $? -ne 0 ]
    		then
	    		panic "failed to create ca-key.pem to AWS"
    		fi
	else
    		aws secretsmanager update-secret --secret-id $cluster/flux/ca.pem --secret-string "$(cat $dir/ca.pem)"
    		if [ $? -ne 0 ]
    		then
	    		panic "failed to update ca.pem to AWS"
    		fi
    		aws secretsmanager update-secret --secret-id $cluster/flux/ca-key.pem --secret-string "$(cat $dir/ca-key.pem)"
    		if [ $? -ne 0 ]
    		then
	    		panic "failed to update ca-key.pem to AWS"
    		fi
	fi
}
	
function make_key {
	info "authorizing access to ${REMOTE_REPO}"

	local key=$(fluxctl --k8s-fwd-ns=flux identity)
	local reponame="$(echo $REMOTE_REPO | cut -d/ -f2 | sed -e 's/\.git//')"
	local cluster=$(get_cluster)

	curl -X POST -i\
		-H"Authorization: token $GITHUB_TOKEN"\
		--data @- https://api.github.com/repos/tidepool-org/$reponame/keys << EOF
	{
	
		"title" : "flux key for $cluster created by make_flux",
		"key" : "$key",
		"read_only" : false
	}
EOF
}

function pull {
	git pull
}

function update_flux {
	info "updating flux and flux-helm-operator manifests"

	if [ -f flux/flux-deployment.yaml ]
	then
		yq r flux/flux-deployment.yaml -j > $TMP_DIR/flux.json
		yq r flux/helm-operator-deployment.yaml -j > $TMP_DIR/helm.json
        	jsonnet  --tla-code-file flux="$TMP_DIR/flux.json"  --tla-code-file helm="$TMP_DIR/helm.json" $QUICKSTART_DIR/flux/flux.jsonnet >$TMP_DIR/updated.json

		add_file flux/flux-deployment-updated.yaml
        	yq r $TMP_DIR/updated.json flux >flux/flux-deployment-updated.yaml

		add_file flux/helm-operator-deployment-updated.yaml
        	yq r $TMP_DIR/updated.json helm >flux/helm-operator-deployment-updated.yaml

		rename_file flux/flux-deployment.yaml flux/flux-deployment.yaml.orig
		mv flux/flux-deployment.yaml flux/flux-deployment.yaml.orig

		rename_file flux/helm-operator-deployment.yaml flux/helm-operator-deployment.yaml.orig
		mv flux/helm-operator-deployment.yaml flux/helm-operator-deployment.yaml.orig
	fi
}

function make_mesh {
	linkerd check --pre
	if [ $? -ne 0 ]
	then
		panic "Failed linkerd pre-check."
	fi
	info "linkerd check --pre"
	
	mkdir -p linkerd
	add_file "linkerd/linkerd-config.yaml"
	linkerd install config > linkerd/linkerd-config.yaml
	linkerd install config | kubectl apply -f -
	
	linkerd check config
	while [ $? -ne 0 ]
	do
    		sleep 3
    		info  "retrying linkerd check config"
    		linkerd check config
	done
	info "linkerd check config"
	
	add_file "linkerd/linkerd-control-plane.yaml"
	linkerd install control-plane > linkerd/linkerd-control-plane.yaml
	linkerd install control-plane | kubectl apply -f -
	
	linkerd check
	while [ $? -ne 0 ]
	do
    		sleep 3
    		info "retrying linkerd check"
    		linkerd check 
	done
	info "linkerd installed"
}


function migrate_secrets {
	local cluster=$(get_cluster)
	info "migrating secrets"
	local env
	for env in $(get_environments)
	do
		local source=$(yq r values.yaml environments.${env}.source)
		info "migrating ${source}"
		if [ "$source" == "dev" -o "$source" == "stg" -o "$source" == "int" -o "$source" == "prd" ]
		then
			$SM_DIR/git_to_map $source | $SM_DIR/map_to_k8s $env 
		else
			panic "Unknown secret source $source"
		fi
	done
}

function upsert {
	local cluster=$(get_cluster)
	external_secret upsert $cluster plaintext | separate_files
}

function make_users {
	local group=system:masters
	local cluster=$(get_cluster)
	local aws_region=$(get_region)
	local aws_account=$(get_account)

	info "adding system masters"
	for user in $(get_iam_users)
	do
    		local arn=arn:aws:iam::${aws_account}:user/${user}
    		eksctl create iamidentitymapping --region=$aws_region  --role=$arn --group=$group --name=$cluster --username=$user
    		while [ $? -ne 0 ]
    		do
	    		sleep 3
    	    		eksctl create iamidentitymapping --region=$aws_region  --role=$arn --group=$group --name=$cluster --username=$user
			info "retrying eksctl create iamidentitymapping"
    		done
    		info "added $user"
	done
}
	

function check_values_not_exist {
	if [ -f values.yaml ]
	then
        	confirm "Are you sure that you want to overwrite prior contents of values.yaml?"
	fi
}

function make_values {
	info "creating values.yaml"
	add_file "values.yaml"
	cp $TMP_DIR/tidepool-quickstart/values.yaml .
	${EDITOR:-vi} values.yaml
}

function edit_config {
	info "exit shell when done making changes."
	bash
	confirm "Are you sure you want to commit changes?"
}

function edit_values {
	if [ -f values.yaml ]
	then
        	info "editing values file for repo $REMOTE_REPO"
		${EDITOR:-vi} values.yaml
	else
		panic "values.yaml does not exist."
	fi
}


function random_secrets {
	for env in $(get_environments)
	do
        	for file in $(find $CHART_DIR -name \*secret.yaml -print)
        	do
                	helm template --namespace $env --set global.secret.generated=true $CHART_DIR  -f  $CHART_DIR/values.yaml -x $file   >$TMP_DIR/x
                	grep "kind" $TMP_DIR/x >/dev/null 2>&1
                	if [ $? -eq 0 ]
                	then
                        	cat $TMP_DIR/x
                	fi
                	rm $TMP_DIR/x
        	done
	done
}

function delete_cluster {
	cluster=$(get_cluster)
	confirm "Are you sure that you want to delete cluster $cluster?"
	eksctl delete cluster --name=$cluster
}

function remove_mesh {
	info "removing linkerd"
	linkerd install --ignore-cluster | kubectl delete -f -
	rm -rf linkerd
}

function install_tools {
	info "installing tools"
	brew bundle --file=${DEV_DIR}/Brewfile
	pip3 install boto3 --user
}

function help {
      echo "$0 [-h|--help] (tools|values|edit_values|config|edit|cluster|flux|cert|assets|mesh|migrate_secrets|plaintext_secrets|users|deploy_key|delete_cluster|remove_mesh|kubeconfig)*"
}

if [ $# -eq 0 ]
then
	help
	exit 0
fi

APPROVE=false
PARAMS=""
while (( "$#" )); do
  case "$1" in
    -y|--approve)
      APPROVE=true
      shift 1
      ;;
    -h|--help)
      help
      exit 0
      ;;
    --) # end argument parsing
      shift
      break
      ;;
    -*|--*=) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
      PARAMS="$PARAMS $1"
      shift
      ;;
  esac
done
# set positional arguments in their proper place
eval set -- "$PARAMS"

define_colors
check_remote_repo
setup_tmpdir
clone_remote
set_quickstart_dir
set_development_dir

for param in $PARAMS
do
	case $param in 
	edit_values)
		edit_values
		make_config
		save_changes "Edited values. Updated config."
		;;
	values)
		check_values_not_exist
		make_values
		save_changes "Added values"
		;;
	config)
		make_config
		save_changes "Added config packages"
		;;
	cluster)
		make_cluster
		merge_kubeconfig
		make_users
		save_changes "Added cluster and users"
		;;
	flux)
		confirm_github_token
		make_flux
		save_ca
		make_cert
		make_key
		update_flux
		save_changes "Added flux"
		;;
	cert)
		make_cert
		;;
	assets)
		make_assets
		;;
	mesh)
		make_mesh
		save_changes "Added linkerd mesh"
		;;
        random_secrets)
		local cluster=$(get_cluster)
		random_secrets | external_secret upsert $cluster encoded | separate_files
	        save_changes "Added random secrets"
		;;
	migrated_secrets)
		clone_secret_map
		local cluster=$(get_cluster)
		migrate_secrets | external_secret upsert $cluster plaintext | separate_files | add_names
	        save_changes "Added migrated secrets"
		;;
	plaintext_secrets)
		local cluster=$(get_cluster)
		external_secret upsert $cluster plaintext | separate_files | add_names
	        save_changes "Added plaintext secrets"
		;;
	users)
		make_users
		;;
	deploy_key)
		confirm_github_token
		make_key
		;;
	delete_cluster)
		local cluster=$(get_cluster)
		delete_cluster
		info "cluster $cluster deletion  takes ~10 minutes to complete"
		;;
	remove_mesh)
		remove_mesh
		save_changes "Removed mesh."
		;;
	tools)
		install_tools
		info "tools installed"
		;;
	edit)
		edit_config
		save_changes "Manual changes."
		;;
	kubeconfig)
		merge_kubeconfig
		;;
	esac
done

cleanup

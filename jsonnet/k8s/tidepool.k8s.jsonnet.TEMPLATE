local aws = import 'aws.jsonnet';
local kube = import 'kube.jsonnet';
local obj = import 'obj.jsonnet';

local host(config, env) = (
  local gateway = env.groups.ingress.gateway;
  if std.objectHas(gateway.default, 'host')
  then gateway.default.host
  else (
    if gateway.default.protocol == 'http'
    then gateway.http.dnsNames[0]
    else gateway.https.dnsNames[0]
  )
);

local certificateSecretName(config, env) = (
  local certificate = env.groups.ingress.certificate;
  if std.objectHas(certificate, 'secretName')
  then certificate.secretName
  else '%s-tls-secret' % env.name
);

local s3URL(config, env) =
  'https://s3-%s.amazonaws.com' % config.cluster.aws.region;


local roleRequired(config, group) =
  config.groups.kiam.enabled && std.objectHas(group, 'iamRole') && group.iamRole.create;

local iamPermissions(config, env) =
  if config.groups.kiam.enabled
  then {
    'iam.amazonaws.com/permitted': '%s/.*' % env.name,
  } else {
  };

// Compute IAM annotation for group
local iamAnnotations(config, env, group) = (
  local clusterName = config.cluster.name;
  local envName = env.name;
  local groupName = group.name;
  if roleRequired(config, group)
  then {
    deployment+: {
      podAnnotations+: {
        'iam.amazonaws.com/role': '%s-%s-%s' % [clusterName, envName, groupName],
      },
    },
  } else {
  }
);

// Compute Linkerd annotations
local linkerdAnnotations(config, env, group) =
  if config.cluster.mesh.enabled && config.cluster.mesh.name == 'linkerd'
  then {
    deployment+: {
      podAnnotations+: {
        'linkerd.io/inject': 'enabled',
      },
    },
  }
  else {
  };

local combine(config, env, group, key) = {
  [key]+:
    std.foldl(obj.merge, [
      config.cluster[key],
      if std.objectHas(env, key) then env[key] else {},
      if std.objectHas(group, key) then group[key] else {},
    ], {}),
};

local resources(config, env, group) = combine(config, env, group, 'resources');

local securityContext(config, env, group) = combine(config, env, group, 'securityContext');

local deployment(config, env, group) =
  if std.objectHas(group, 'deployment') && std.objectHas(group.deployment, 'env')
  then {
    deployment+: {
      env+: combine(config, env, group.deployment.env, 'store'),
    },
  }
  else {
  };

local ingress(config,env) = {
  local ingress = config.cluster.ingress,
  service+: {
    http: {
      enabled: ingress.service.http.enabled,
    },
    https: {
      enabled: ingress.service.https.enabled,
    },
  },
  deployment: ingress.deployment,
  gateway: env.groups.ingress.gateway + {
    default+: {
        host: host(config, env),
    },
  }
};

local hpas(config, env, group) = combine(config, env, group, 'hpa');

// add default bucket
local getBucket(config, env) =
  {
    store+: {
      bucket: aws.bucketName(config, env),
    },
  };

local groupConfig(config, env, group) = (
  local envWithBucket = env + getBucket(config, env);
  obj.strip(obj.strip(
    group
    + iamAnnotations(config, envWithBucket, group)
    + linkerdAnnotations(config, envWithBucket, group)
    + securityContext(config, envWithBucket, group)
    + resources(config, envWithBucket, group)
    + deployment(config, envWithBucket, group)
    + hpas(config, envWithBucket, group),
    'secret'
  ), 'iamRole')
);

local isAutomated(group) =
  std.objectHas(group, 'deployment') &&
  std.objectHas(group.deployment, 'gitops') &&
  group.deployment.gitops.automated;

local HelmRelease(config, env) = aws.helmrelease(config, env) {
  local hr = env.helmrelease,
  metadata+: {
    name: 'tidepool',
    namespace: env.name,
    annotations: {
      ['flux.weave.works/tag.' + group.name]: (hr.gitops.selector + ':' + hr.gitops.filter)
      for group in obj.values(env.groups)
      if isAutomated(group)
    } + {
      'flux.weave.works/automated': hr.gitops.automated,
    },
  },
  spec+: {
    releaseName: env.name + '-tidepool',
    values: {
      gloo: {
        enabled: false,
      },
      tidepool: {
        namespace+: {
          annotations+: iamPermissions(config, env),
        },
      },
      global+: {
        region: config.cluster.aws.region,
        logLevel: config.cluster.logLevel,
      },
    } + {
      [group.name]: groupConfig(config, env, group) for group in obj.values(env.groups) if std.objectHas(group, 'deployment')
    } + {
      ingress: ingress(config, env),
    } + {
      mongodb: {
        enabled: false // XXX
      }
    }
  },
};

local namespace(name, env) = if env.namespace.create then aws.namespace(config, env);

function(config) (
  local helmRelease(name, env) = if env.enabled then HelmRelease(config, env);
  local helmReleases = std.mapWithKey(helmRelease, config.tidepool.groups);
  obj.values(std.prune(helmReleases))
)
